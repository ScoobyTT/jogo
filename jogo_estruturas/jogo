#include <iostream>
#include <string>
#include <vector> // Para facilitar a passagem de arrays de string para adicionarFalas
#include <limits> // Para numeric_limits
#include <algorithm> // Para std::sort ou outras operações de lista
#include <fstream>

using namespace std;

// Estrutura para os nós da lista de falas (já existente)
struct Lista {
    string texto;
    Lista* prox;
    Lista* ant;
};

// Estrutura para os nós da árvore de decisão
struct Nodo {
    Lista* falas;
    Nodo* op1; // esquerda
    Nodo* op2; // direita
};

struct jogadorScore {
    string nome;
    int total_jogos;
    int vitorias;
    int derrotas;
};

// Nó para a lista duplamente encadeada de scores
struct ScoreNodo {
    jogadorScore jogador;
    ScoreNodo* prox;
    ScoreNodo* ant;
};

class Jogo {
private:
    Nodo* raiz;
    ScoreNodo* scoreInicio; // Início da lista de scores
    ScoreNodo* scoreFim;    // Fim da lista de scores

    // Adicione uma variável para manter o jogador atual durante o jogo.
    string jogadorAtualNome;

public:
    // Construtor
    Jogo() : raiz(nullptr), scoreInicio(nullptr), scoreFim(nullptr) {
        // No construtor, você pode tentar carregar scores de um arquivo aqui.
        carregarScores(); // Função a ser implementada
        construirCenas(); // Chame construirCenas no construtor para inicializar a árvore
    }

    // Métodos de Score
    void carregarScores() {
        ifstream arquivo("scores.txt");
        if (!arquivo.is_open()) {
            std::cout << "(Arquivo de scores não encontrado ou erro ao abrir. Criando um novo.)" << endl;
            return;
        }

        string nome;
        int total_jogos, vitorias, derrotas;
        string line;

        while (getline(arquivo, line)) {
            size_t pos1 = line.find(',');
            size_t pos2 = line.find(',', pos1 + 1);
            size_t pos3 = line.find(',', pos2 + 1);

            if (pos1 == string::npos || pos2 == string::npos || pos3 == string::npos) {
                // Erro na linha, pule-a
                continue;
            }

            nome = line.substr(0, pos1);
            total_jogos = stoi(line.substr(pos1 + 1, pos2 - (pos1 + 1)));
            vitorias = stoi(line.substr(pos2 + 1, pos3 - (pos2 + 1)));
            derrotas = stoi(line.substr(pos3 + 1));

            jogadorScore loadedJogador = {nome, total_jogos, vitorias, derrotas};
            adicionarScore(loadedJogador); // Usa a função adicionarScore para manter a ordem
        }
        arquivo.close();
        std::cout << "(Scores carregados do arquivo 'scores.txt')" << endl;
    }

    void adicionarScore(const jogadorScore& novoJogador) {
        ScoreNodo* novaNode = new ScoreNodo{novoJogador, nullptr, nullptr};

        if (scoreInicio == nullptr) { // Lista vazia
            scoreInicio = novaNode;
            scoreFim = novaNode;
        } else {
            // Insercao ordenada por vitorias (decrescente)
            ScoreNodo* atual = scoreInicio;
            while (atual != nullptr && novoJogador.vitorias <= atual->jogador.vitorias) {
                // Se vitorias iguais, pode ordenar por total_jogos (crescente) ou nome
                if (novoJogador.vitorias == atual->jogador.vitorias && novoJogador.total_jogos >= atual->jogador.total_jogos) {
                    // Mantem a ordem se vitorias iguais, inserindo depois de quem tem menos jogos
                    atual = atual->prox;
                } else if (novoJogador.vitorias < atual->jogador.vitorias) {
                    atual = atual->prox;
                } else {
                    break; // Encontrou a posicao correta
                }
            }
            if (atual == nullptr) { // Inserir no fim
                scoreFim->prox = novaNode;
                novaNode->ant = scoreFim;
                scoreFim = novaNode;
            } else if (atual == scoreInicio) { // Inserir no inicio
                novaNode->prox = scoreInicio;
                scoreInicio->ant = novaNode;
                scoreInicio = novaNode;
            } else { // Inserir no meio
                novaNode->prox = atual;
                novaNode->ant = atual->ant;
                atual->ant->prox = novaNode;
                atual->ant = novaNode;
            }
        }
        // Não chame salvarScores aqui, pois carregarScores já chamaria e causaria loops ou saves desnecessários
        // SalvarScores será chamado no destrutor ou quando explicitamente solicitado pelo usuário.
    }

    void atualizarScore(const string& nomeJogador, bool venceu) {
        ScoreNodo* atual = scoreInicio;
        while (atual != nullptr) {
            if (atual->jogador.nome == nomeJogador) {
                atual->jogador.total_jogos++;
                if (venceu) {
                    atual->jogador.vitorias++;
                } else {
                    atual->jogador.derrotas++;
                }
                // Remover e adicionar novamente para manter a ordenacao
                jogadorScore tempJogador = atual->jogador; // Salva os dados antes de remover o nó
                removerScoreNode(atual);
                adicionarScore(tempJogador); // Adiciona novamente para reordenar
                return;
            }
            atual = atual->prox;
        }

        // Se o jogador nao foi encontrado, adiciona um novo
        jogadorScore novo = {nomeJogador, 1, (venceu ? 1 : 0), (venceu ? 0 : 1)};
        adicionarScore(novo);
    }

    void removerScoreNode(ScoreNodo* nodeToRemove) {
        if (nodeToRemove == nullptr) return;

        if (nodeToRemove->ant) {
            nodeToRemove->ant->prox = nodeToRemove->prox;
        } else { // Era o inicio
            scoreInicio = nodeToRemove->prox;
        }

        if (nodeToRemove->prox) {
            nodeToRemove->prox->ant = nodeToRemove->ant;
        } else { // Era o fim
            scoreFim = nodeToRemove->ant;
        }
        delete nodeToRemove;
    }

    void verificarScore() {
        using namespace std;
        cout << "\n--- Score dos Jogadores ---" << endl;
        if (scoreInicio == nullptr) {
            cout << "Nenhum score registrado ainda." << endl;
            cout << "Pressione Enter para voltar ao menu..." << endl;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return;
        }

        ScoreNodo* atual = scoreInicio;
        int rank = 1;
        while (atual != nullptr) {
            cout << rank << ". Nome: " << atual->jogador.nome
                 << " | Jogos: " << atual->jogador.total_jogos
                 << " | Vitorias: " << atual->jogador.vitorias
                 << " | Derrotas: " << atual->jogador.derrotas << endl;
            atual = atual->prox;
            rank++;
        }
        cout << "Pressione Enter para voltar ao menu..." << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    // Métodos da Árvore
    Lista* adicionarFalas(const string textos[], int n) { // Usando vector para flexibilidade
        Lista* inicio = nullptr;
        Lista* fim = nullptr;
        for (int i = 0; i < n; ++i) { // Loop correto para array C-style
            Lista* nova = new Lista{textos[i], nullptr, nullptr};
            if (inicio == nullptr) {
                inicio = nova;
                fim = nova;
            } else {
                fim->prox = nova;
                nova->ant = fim;
                fim = nova;
            }
        }
        return inicio;
    }

    Nodo* criarNodo(const string textos[], int n) { // Adicionado 'int n' ao criarNodo
        Nodo* novo = new Nodo;
        novo->falas = adicionarFalas(textos, n); // Passa 'n'
        novo->op1 = nullptr;
        novo->op2 = nullptr;
        return novo;
    }
/*
    void construirCenas() {
        // Cena raiz
        string falas_raiz[] = {"Você acorda em uma floresta misteriosa.", "Dois caminhos se abrem: esquerda e direita."};
        raiz = criarNodo(falas_raiz, 2);

        // Esquerda da raiz
        string falas_op1[] = {"Você segue pela esquerda e encontra um lago brilhante.", "Um barulho estranho vem da água."};
        raiz->op1 = criarNodo(falas_op1, 2);

        // Direita da raiz
        string falas_op2[] = {"Você segue pela direita e encontra uma caverna escura.", "Uma sombra se move dentro dela."};
        raiz->op2 = criarNodo(falas_op2, 2);

        // Filhos da esquerda (raiz->op1)
        string falas_op1_op1[] = {"Você se aproxima do lago e vê uma criatura mágica.", "Ela oferece uma poção. Você bebe e sente um poder estranho. VITÓRIA!"};
        raiz->op1->op1 = criarNodo(falas_op1_op1, 2); // Final de vitória

        string falas_op1_op2[] = {"Você ignora o lago e continua andando pela mata.", "Um grupo de viajantes aparece e o acolhe. Final pacífico. VITÓRIA!"};
        raiz->op1->op2 = criarNodo(falas_op1_op2, 2); // Final de vitória

        // Filhos da direita (raiz->op2)
        string falas_op2_op1[] = {"Você entra na caverna e encontra um baú trancado.", "Há símbolos antigos nas paredes. Você tenta abrir o baú e fica preso! Fim da aventura. DERROTA!"};
        raiz->op2->op1 = criarNodo(falas_op2_op1, 2); // Final de derrota

        string falas_op2_op2[] = {"Você contorna a caverna e chega ao topo de uma montanha.", "A vista é deslumbrante, mas há uma tempestade se aproximando. Você é atingido por um raio. Fim da aventura. DERROTA!"};
        raiz->op2->op2 = criarNodo(falas_op2_op2, 2); // Final de derrota
    }

*/

    void exibirCena(Nodo* nodo) {
        Lista* atual = nodo->falas;
        while (atual != nullptr) {
            std::cout << atual->texto << std::endl;
            atual = atual->prox;
        }
    }

    // Métodos de Jogo e Menu
    void exibirMenuPrincipal() {
        int escolha;
        do {
            using namespace std;
            cout << "\n=== JOGO-ED1: Uma Aventura com Árvores de Decisão ===" << endl
                 << "1. Conhecer a História do Jogo" << endl // Adicionado endl para quebra de linha
                 << "2. Regras do Jogo" << endl
                 << "3. Jogar" << endl
                 << "4. Verificar Score" << endl
                 << "5. Informações Técnicas" << endl // Adicionado opção para Informações Técnicas
                 << "0. Sair" << endl
                 << "-----------------------------------------------------" << endl
                 << "Escolha uma opcao: ";
            cin >> escolha;
            // Limpa o buffer do teclado
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            switch (escolha) {
                case 1:
                    mostrarHistoria();
                    break;
                case 2:
                    mostrarRegras();
                    break;
                case 3:
                    jogar();
                    break;
                case 4:
                    verificarScore();
                    break;
                case 5: // Chamada para o menu de informações técnicas
                    exibirInformacoesTecnicas();
                    break;
                case 0:
                    gerenciarSaida(); // Pergunta se quer salvar antes de sair
                    cout << "Obrigado por jogar! Saindo..." << endl;
                    // Destruição da árvore e scores é feita no destrutor da classe Jogo
                    exit(0); // Encerra o programa
                    break;
                default:
                    cout << "Opcao invalida. Tente novamente." << endl;
            }
        } while (escolha != 0);
    }

    void mostrarHistoria() {
        using namespace std;
        cout << "\n--- Historia do Jogo ---" << endl;
        cout << "Este é um jogo de aventura onde suas escolhas moldam seu destino." << endl;
        cout << "Você acorda em um local misterioso e deve navegar por caminhos perigosos." << endl;
        cout << "Cada decisão pode levar a uma vitoria gloriosa ou a uma derrota inesperada." << endl;
        cout << "Boa sorte, aventureiro!" << endl;
        cout << "Pressione Enter para voltar ao menu..." << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    void mostrarRegras() {
        using namespace std;
        cout << "\n--- Regras do Jogo ---" << endl;
        cout << "1. Leia atentamente a descricao de cada cena." << endl;
        cout << "2. Escolha entre as opcoes disponiveis (geralmente 1 para Esquerda, 2 para Direita)." << endl;
        cout << "3. Suas escolhas sao permanentes e afetarao o desfecho do jogo." << endl;
        cout << "4. O objetivo e alcancar um final de vitoria. Um final de derrota termina o jogo." << endl;
        cout << "Pressione Enter para voltar ao menu..." << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    void jogar() {
        using namespace std;
        cout << "\n--- Iniciar Novo Jogo ---" << endl;
        cout << "Qual o seu nome, aventureiro? ";
        getline(cin, jogadorAtualNome);

        Nodo* atual = raiz;
        bool jogo_ativo = true;
        bool vitoria_atual = false;

        while (atual != nullptr && jogo_ativo) {
            cout << "Seja bem vindo a aventura" <<jogadorAtualNome << ""
                 << "Sua aventura começa a partir dessas escolhas: \n"
                 << "\n--- Cena Atual ---" << endl;
            exibirCena(atual);

            // Verifica se é um nó folha (fim de jogo)
            if (atual->op1 == nullptr && atual->op2 == nullptr) {
                // Lógica para determinar vitória ou derrota nos nós folha
                // Adaptado para os novos finais de vitória/derrota
                if (atual == raiz->op1->op1 || atual == raiz->op1->op2) { // Caminhos de vitória
                    cout << "\nParabéns! Você alcançou um final de VITÓRIA!" << endl;
                    vitoria_atual = true;
                } else if (atual == raiz->op2->op1 || atual == raiz->op2->op2) { // Caminhos de derrota
                    cout << "\nQue pena! Você alcançou um final de DERROTA!" << endl;
                    vitoria_atual = false;
                } else {
                    cout << "\nFim da aventura. Final desconhecido." << endl; // Para outros nós folha não categorizados
                    vitoria_atual = false;
                }
                jogo_ativo = false; // Termina o loop do jogo
            } else {
                int escolha;
                cout << "\nEscolha seu proximo passo: ";
                if (atual->op1 != nullptr) cout << "[1] Esquerda ";
                if (atual->op2 != nullptr) cout << "[2] Direita ";
                cout << "| [0] Sair do jogo\n> ";
                cin >> escolha;
                cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Limpa o buffer

                if (escolha == 1 && atual->op1 != nullptr) {
                    atual = atual->op1;
                } else if (escolha == 2 && atual->op2 != nullptr) {
                    atual = atual->op2;
                } else if (escolha == 0) {
                    cout << "Saindo do jogo atual..." << endl;
                    jogo_ativo = false;
                    vitoria_atual = false; // Considera sair como derrota para estatísticas se não houver um final claro
                } else {
                    cout << "Escolha invalida ou caminho inexistente. Tente novamente." << endl;
                    // Permite ao jogador tentar novamente sem avançar ou terminar o jogo
                }
            }
        }

        // Após o jogo terminar ou o jogador sair
        if (!jogadorAtualNome.empty()) { // Verifica se um nome de jogador foi inserido
            atualizarScore(jogadorAtualNome, vitoria_atual);
        }
        exibirMenuPosJogo(); // Exibe o menu pós-jogo
    }

    // Menu Pos-Jogo
    void exibirMenuPosJogo() {
        using namespace std;
        int escolha;
        do {
            cout << "\n--- Fim de Jogo ---" << endl;
            cout << "1. Deseja Jogar Novamente?" << endl;
            cout << "2. Verificar Score" << endl;
            cout << "0. Fechar o jogo" << endl;
            cout << "----------------------" << endl;
            cout << "Escolha uma opcao: ";
            cin >> escolha;

            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            switch (escolha) {
                case 1:
                    // Não é necessário destruir e recriar a árvore e scores aqui,
                    // pois os scores são atualizados e a árvore de cenas é estática.
                    // Apenas chamar 'jogar()' novamente.
                    cout << "Iniciando um novo jogo..." << endl;
                    jogar(); // Inicia um novo jogo
                    break;
                case 2:
                    verificarScore();
                    break;
                case 0:
                    cout << "Fechando o jogo. Obrigado por jogar!" << endl;
                    gerenciarSaida(); // Pergunta se quer salvar antes de sair
                    exit(0); // Encerra o programa
                    break;
                default:
                    cout << "Opcao invalida. Tente novamente." << endl;
            }
        } while (escolha != 0);
    }

    // Menu de Informacoes Tecnicas
    void exibirInformacoesTecnicas() {
        using namespace std;
        int escolha;
        do {
            cout << "\n--- Informacoes Tecnicas ---" << endl;
            cout << "1. Mostrar a lista de falas de um nodo (Ex: Cena Raiz)" << endl; // Adapte para mostrar uma lista específica
            cout << "2. Listar a arvore em ordem (percurso)" << endl;
            cout << "3. Buscar estatisticas de jogo por nome/numero de jogos" << endl;
            cout << "0. Voltar ao menu anterior" << endl;
            cout << "----------------------------" << endl;
            cout << "Escolha uma opcao: ";
            cin >> escolha;

            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            switch (escolha) {
                case 1:
                    // Exemplo: mostrar falas da raiz
                    cout << "\n--- Falas da Cena Raiz ---" << endl;
                    if (raiz) exibirCena(raiz);
                    else cout << "Arvore nao construida." << endl;
                    break;
                case 2:
                    cout << "\n--- Listando Arvore em Ordem (Pre-ordem) ---" << endl;
                    // É melhor ter uma função wrapper para chamar o percurso recursivo com um nó inicial
                    if (raiz) {
                        listarArvoreEmOrdem(raiz);
                    } else {
                        cout << "Arvore de cenas vazia." << endl;
                    }
                    break;
                case 3:
                    buscarEstatisticas();
                    break;
                case 0:
                    cout << "Voltando..." << endl;
                    break;
                default:
                    cout << "Opcao invalida. Tente novamente." << endl;
            }
            cout << "Pressione Enter para continuar..." << endl;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        } while (escolha != 0);
    }

    // Corrigido para ser uma função recursiva que percorre a árvore
    void listarArvoreEmOrdem(Nodo* nodo) { // Exemplo de percurso em pre-ordem (se quiser in-order ou post-order, a ordem da chamada muda)
        using namespace std;
        if (nodo == nullptr) return; // Base da recursão

        cout << "Cena: ";
        if (nodo->falas && !nodo->falas->texto.empty()) { // Verifica se há falas e se o texto não é vazio
            if (nodo->falas->texto.length() > 20) {
                cout << "\"" << nodo->falas->texto.substr(0, 20) << "..." << "\"" << endl;
            } else {
                cout << "\"" << nodo->falas->texto << "\"" << endl;
            }
        } else {
            cout << "(Sem texto)" << endl;
        }

        listarArvoreEmOrdem(nodo->op1); // Visita a subárvore esquerda
        listarArvoreEmOrdem(nodo->op2); // Visita a subárvore direita
    }

    void buscarEstatisticas() {
        using namespace std;
        cout << "\n--- Buscar Estatisticas ---" << endl;
        cout << "1. Buscar por nome do jogador" << endl;
        cout << "2. Buscar por numero de jogos ganhos (Minimo)" << endl; // Exemplo
        cout << "0. Voltar" << endl;
        cout << "Escolha uma opcao: ";

        int escolha;
        cin >> escolha;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        switch (escolha) {
            case 1: {
                string nomeBusca;
                cout << "Digite o nome do jogador: ";
                getline(cin, nomeBusca);
                ScoreNodo* atual = scoreInicio;
                bool encontrado = false;
                while (atual != nullptr) {
                    if (atual->jogador.nome == nomeBusca) {
                        cout << "Nome: " << atual->jogador.nome
                             << " | Jogos: " << atual->jogador.total_jogos
                             << " | Vitorias: " << atual->jogador.vitorias
                             << " | Derrotas: " << atual->jogador.derrotas << endl;
                        encontrado = true;
                        break;
                    }
                    atual = atual->prox;
                }
                if (!encontrado) {
                    cout << "Jogador '" << nomeBusca << "' nao encontrado." << endl;
                }
                break;
            }
            case 2: { // Exemplo: Buscar jogadores com mais de X vitórias
                int minVitorias;
                cout << "Digite o numero minimo de vitorias: ";
                cin >> minVitorias;
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                ScoreNodo* atual = scoreInicio;
                bool encontrado = false;
                cout << "Jogadores com " << minVitorias << " ou mais vitorias:" << endl;
                while (atual != nullptr) {
                    if (atual->jogador.vitorias >= minVitorias) {
                        cout << "Nome: " << atual->jogador.nome
                             << " | Jogos: " << atual->jogador.total_jogos
                             << " | Vitorias: " << atual->jogador.vitorias
                             << " | Derrotas: " << atual->jogador.derrotas << endl;
                        encontrado = true;
                    }
                    atual = atual->prox;
                }
                if (!encontrado) {
                    cout << "Nenhum jogador encontrado com essa quantidade de vitorias." << endl;
                }
                break;
            }
            case 0:
                break;
            default:
                cout << "Opcao invalida." << endl;
        }
    }

    void gerenciarSaida() {
        using namespace std;
        int escolhaSalvar;
        cout << "Deseja salvar seu progresso antes de sair?" << endl;
        cout << "1. Sim" << endl;
        cout << "2. Nao" << endl;
        cout << "Escolha: ";
        cin >> escolhaSalvar;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Limpa buffer
        if (escolhaSalvar == 1) {
            salvarScores(); // Chama a funcao salvarScores
            std::cout << "Scores salvos com sucesso!" << std::endl;
        } else {
            cout << "Scores nao salvos." << std::endl;
        }
    }

    // Destrutor e Liberacao de Memoria
    ~Jogo() {
        salvarScores(); // Salva scores ao fechar o programa
        destruirArvore(raiz);
        destruirScores();
        // Nao chame destruirCenas(raiz) separadamente, pois destruirArvore já cuida disso.
    }

private:
    // Funções auxiliares para destruir a árvore e liberar memória
    void destruirArvore(Nodo* nodo) {
        if (nodo == nullptr) return;
        destruirArvore(nodo->op1);
        destruirArvore(nodo->op2);

        // Libera a lista de falas de cada nodo
        Lista* atual = nodo->falas;
        while (atual != nullptr) {
            Lista* temp = atual;
            atual = atual->prox;
            delete temp;
        }
        delete nodo;
    }

    void destruirScores() {
        ScoreNodo* atual = scoreInicio;
        while (atual != nullptr) {
            ScoreNodo* temp = atual;
            atual = atual->prox;
            delete temp;
        }
        scoreInicio = nullptr;
        scoreFim = nullptr;
    }

    // Esta função era um duplicata de destruirArvore e foi removida ou consolidada.
    // O problema original chamava 'destruirCenas(raiz)' junto com 'destruirArvore(raiz)'
    // e possuía uma sintaxe incorreta no cabeçalho.
    // A função destruirArvore já lida com a liberação de memória dos Nodos e suas Listas de falas.
    // Se você tiver uma estrutura de dados de "cenas" separada que não são os Nodos da árvore,
    // então esta função deveria ser mantida com uma lógica própria.
    // No entanto, pelo código fornecido, os "Nodos" *são* as "cenas".
    // Portanto, o `destruirCenas` original foi removido para evitar duplo-delete.
    // Mantenho o comentário para deixar claro o motivo da remoção/revisão.
    /*
    void destruirCenas(Nodo* nodo){
        if(nodo == nullptr) return;
        destruirCenas(nodo->op1);
        destruirCenas(nodo->op2);
        Lista* atual = nodo->falas;
        while (atual != nullptr) {
            Lista* temp = atual;
            atual = atual->prox;
            delete temp;
        }
        delete nodo;
    }
    */

    void salvarScores() {
        using namespace std;
        ofstream arquivo("scores.txt");
        if (!arquivo.is_open()) {
            cout << "Erro ao abrir o arquivo para salvar scores." << endl;
            return;
        }
        ScoreNodo* atual = scoreInicio;
        if (atual == nullptr) {
            cout << "Nenhum score para salvar." << endl;
            arquivo.close();
            return;
        } else {
            while (atual != nullptr) {
                arquivo << atual->jogador.nome << ","
                        << atual->jogador.total_jogos << ","
                        << atual->jogador.vitorias << ","
                        << atual->jogador.derrotas << endl;
                atual = atual->prox;
            }
        }
        arquivo.close(); // Fechar o arquivo após escrever
        cout << "(Scores salvos no arquivo 'scores.txt')" << endl;
    }
};

// Funcao main para iniciar o jogo
int main() {
    Jogo meuJogo;
    // meuJogo.construirCenas(); // Já é chamado no construtor de Jogo
    meuJogo.exibirMenuPrincipal(); // Inicia o loop principal do menu
    // meuJogo.menuPosJogo(); // Esta linha não deve ser chamada aqui, é chamada dentro de jogar()
    return 0;
}
