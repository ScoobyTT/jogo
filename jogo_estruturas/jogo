#ifndef HISTORIA_H
#define HISTORIA_H
#include <iostream>
#include <string>
#include <vector> // Incluído para consistência, embora não seja estritamente usado na Cena

// A estrutura Cena é a base da nossa árvore de decisão de jogo.
struct Cena {
    std::string texto;
    std::string escolha1;
    std::string escolha2;
    Cena* op1 = nullptr; // Opção 1 leva a esta cena
    Cena* op2 = nullptr; // Opção 2 leva a esta cena
    bool is_victory_ending = false; // Indica se esta cena é um final de vitória
    bool is_defeat_ending = false; // Indica se esta cena é um final de derrota

    Cena(std::string t, std::string e1 = "", std::string e2 = "", bool victory = false, bool defeat = false) {
        texto = t;
        escolha1 = e1;
        escolha2 = e2;
        is_victory_ending = victory;
        is_defeat_ending = defeat;
    }
};

#endif // HISTORIA_H

// --- Fim do conteúdo de historia.h ---

#include <iostream>
#include <string>
#include <vector>
#include <limits>   // Para numeric_limits
#include <fstream>
// Não precisamos mais de "historiaa.h" se Cena estiver definida acima e não houver outros itens lá.

using namespace std;

// Estrutura para o score do jogador
struct jogadorScore {
    string nome;
    int total_jogos;
    int vitorias;
    int derrotas;
};

// Nó para a lista duplamente encadeada de scores
struct ScoreNodo {
    jogadorScore jogador;
    ScoreNodo* prox;
    ScoreNodo* ant;
};

class Jogo {
private:
    Cena* raizCena;          // Raiz da árvore de cenas do jogo (usando Cena)
    ScoreNodo* scoreInicio;  // Início da lista de scores
    ScoreNodo* scoreFim;     // Fim da lista de scores
    string jogadorAtualNome; // Nome do jogador atual

public:
    // Construtor
    Jogo() : raizCena(nullptr), scoreInicio(nullptr), scoreFim(nullptr) {
        carregarScores();
        construirCenas(); // Chama a função para construir a árvore de cenas
    }

    // Função para construir as cenas do jogo (adaptado do seu 'historia::jogo')
    void construirCenas() {
        // Cenas - Marcando explicitamente os finais de vitória/derrota
        Cena* c1 = new Cena(
            "Você acorda em um buraco, o qual não teria caído se prestasse mais atenção. Você vê um grande cipó pendurado do topo até você.\nO que vai fazer?",
            "Subir até o topo pelo cipó.",
            "Investigar seus bolsos."
        );
        Cena* c2 = new Cena(
            "Você sobe no cipó, mas ele era frágil demais. Você cai e desmaia outra vez. Que ideia em...\nGame Over.",
            "", "", false, true // Final de derrota
        );
        Cena* c3 = new Cena(
            "Você investiga seus bolsos e encontra seu celular. O sinal está fraco e a bateria também. O que vai fazer?",
            "Subir no cipó para tentar mais sinal.",
            "Ligar a lanterna para investigar o local."
        );
        Cena* c4 = new Cena(
            "Você sobe com o celular na mão. Está perto do topo, mas sem sinal. Você estica o braço, se desequilibra e cai. Você e seu celular estão inteiros, por sorte.\nO que vai fazer?",
            "Ligar para alguém e jogar o celular para fora.",
            "Tentar sair subindo pelo cipó novamente."
        );
        Cena* c5 = new Cena(
            "Você liga para emergência, coloca no viva-voz e joga o celular pra fora. Alguém atende. O resgate está chegando. Você está a salvo!",
            "", "", true, false // Final de vitória
        );
        Cena* c6 = new Cena(
            "Seu plano falha e você cai, desmaiando. Você já tentou isso antes, não tentou?\nGame Over.",
            "", "", false, true // Final de derrota
        );
        Cena* c7 = new Cena(
            "Você liga a lanterna e investiga o local, mas não acha nada. O que vai fazer?",
            "Investigar outra vez.",
            "Escolher uma música."
        );
        Cena* c8 = new Cena(
            "Você investiga de novo, mas a bateria acaba. O que vai fazer?",
            "Gritar por ajuda."
        );
        Cena* c9 = new Cena(
            "Você grita... e atrai uma onça selvagem. Ela nem pula no buraco, mas você desmaia de medo.\nGame Over.",
            "", "", false, true // Final de derrota
        );
        Cena* c10 = new Cena(
            "Você só tem duas músicas. Qual vai escolher?",
            "Música de seresta.",
            "Música de balada."
        );
        Cena* c11 = new Cena(
            "Você toca a música de seresta. Começa a chover. A água sobe, e você flutua até a saída do buraco.\nVocê está salvo!",
            "", "", true, false // Final de vitória
        );
        Cena* c12 = new Cena(
            "Você toca música de balada. É animada e contagiante. O que vai fazer?",
            "Dançar.",
            "Gritar sem motivo."
        );
        Cena* c13 = new Cena(
            "Você dança animado. Sua mente imagina se conseguiria subir o cipó suado. Você vai tentar?",
            "Xingar o narrador e subir pelo cipó.",
            "Bajular o narrador."
        );
        Cena* c14 = new Cena(
            "Você xinga o narrador e tenta subir... e consegue??? Qual a lógica disso? Mas você está a salvo!",
            "", "", true, false // Final de vitória
        );
        Cena* c15 = new Cena(
            "Você bajula o narrador. Uma escada aparece magicamente. Parabéns, você está a salvo!",
            "", "", true, false // Final de vitória
        );
        Cena* c16 = new Cena(
            "Você grita sem motivo. Uma onça aparece e te encara. O que vai fazer?",
            "Tacar o celular na onça.",
            "Pedir ajuda ao animal."
        );
        Cena* c17 = new Cena(
            "Você taca o celular na onça. Ela se assusta, escorrega e cai no buraco.\nFim trágico. Game Over.",
            "", "", false, true // Final de derrota
        );
        Cena* c18 = new Cena(
            "Você implora ajuda à onça. Ela sente pena, entra no buraco e te carrega pra fora. Você está salvo!",
            "", "", true, false // Final de vitória
        );      

        // Ligando as cenas (construindo a árvore)
        c1->op1 = c2;
        c1->op2 = c3;

        c3->op1 = c4;
        c3->op2 = c7;

        c4->op1 = c5;
        c4->op2 = c6;

        c7->op1 = c8;
        c7->op2 = c10;

        c8->op1 = c9; // c8 só tem uma opção que leva a c9 (derrota)

        c10->op1 = c11;
        c10->op2 = c12;

        c12->op1 = c13;
        c12->op2 = c16;

        c13->op1 = c14;
        c13->op2 = c15;

        c16->op1 = c17;
        c16->op2 = c18;

        raizCena = c1; // Define a cena inicial do jogo
    }

    // Função para rodar a narrativa do jogo (agora usa Cena*)
    void jogarCena(Cena* atual) {
        while (atual != nullptr) {
            cout << "\n" << atual->texto << "\n";

            // Verifica se é um final (vitória ou derrota)
            if (atual->is_victory_ending) {
                cout << "\n>>> Parabéns! Você alcançou um final de VITÓRIA! <<<\n";
                atualizarScore(jogadorAtualNome, true);
                return; // Encerra a função, o jogo termina
            } else if (atual->is_defeat_ending) {
                cout << "\n>>> Que pena! Você alcançou um final de DERROTA! <<<\n";
                atualizarScore(jogadorAtualNome, false);
                return; // Encerra a função, o jogo termina
            }

            // Se não for um final, apresenta as opções
            if (atual->op1) cout << "1 - " << atual->escolha1 << "\n";
            if (atual->op2) cout << "2 - " << atual->escolha2 << "\n";

            int escolha;
            cout << "Escolha: ";
            // Loop para garantir entrada válida
            while (!(cin >> escolha) || (escolha != 1 && escolha != 2 && escolha != 0)) {
                cout << "Escolha inválida. Digite 1, 2 ou 0 para sair: ";
                cin.clear(); // Limpa o estado de erro do cin
                cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Descarta a entrada inválida
            }
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Limpa o buffer após a leitura

            if (escolha == 1 && atual->op1) {
                atual = atual->op1;
            } else if (escolha == 2 && atual->op2) {
                atual = atual->op2;
            } else if (escolha == 0) {
                cout << "Saindo do jogo atual..." << endl;
                atualizarScore(jogadorAtualNome, false); // Considera sair como derrota
                return;
            } else {
                // Caso a escolha seja válida mas a opção não exista (ex: 2 mas op2 é nullptr)
                cout << "Opção não disponível. Tente novamente." << endl;
                // Permanece na cena atual para nova escolha
            }
        }
    }

    // Métodos de Score
    void carregarScores() {
        ifstream arquivo("scores.txt");
        if (!arquivo.is_open()) {
            cout << "(Arquivo de scores não encontrado ou erro ao abrir. Criando um novo.)" << endl;
            return;
        }

        string nome;
        int total_jogos, vitorias, derrotas;
        string line;

        while (getline(arquivo, line)) {
            size_t pos1 = line.find(',');
            size_t pos2 = line.find(',', pos1 + 1);
            size_t pos3 = line.find(',', pos2 + 1);

            if (pos1 == string::npos || pos2 == string::npos || pos3 == string::npos) {
                // Erro na linha, pule-a
                continue;
            }

            nome = line.substr(0, pos1);
            total_jogos = stoi(line.substr(pos1 + 1, pos2 - (pos1 + 1)));
            vitorias = stoi(line.substr(pos2 + 1, pos3 - (pos2 + 1)));
            derrotas = stoi(line.substr(pos3 + 1));

            jogadorScore loadedJogador = {nome, total_jogos, vitorias, derrotas};
            adicionarScore(loadedJogador); // Usa a função adicionarScore para manter a ordem
        }
        arquivo.close();
        cout << "(Scores carregados do arquivo 'scores.txt')" << endl;
    }

    void adicionarScore(const jogadorScore& novoJogador) {
        ScoreNodo* novaNode = new ScoreNodo{novoJogador, nullptr, nullptr};

        if (scoreInicio == nullptr) { // Lista vazia
            scoreInicio = novaNode;
            scoreFim = novaNode;
        } else {
            // Insercao ordenada por vitorias (decrescente)
            ScoreNodo* atual = scoreInicio;
            while (atual != nullptr && novoJogador.vitorias <= atual->jogador.vitorias) {
                // Se vitorias iguais, pode ordenar por total_jogos (crescente) ou nome
                if (novoJogador.vitorias == atual->jogador.vitorias && novoJogador.total_jogos >= atual->jogador.total_jogos) {
                    // Mantem a ordem se vitorias iguais, inserindo depois de quem tem menos jogos
                    atual = atual->prox;
                } else if (novoJogador.vitorias < atual->jogador.vitorias) {
                    atual = atual->prox;
                } else {
                    break; // Encontrou a posicao correta
                }
            }
            if (atual == nullptr) { // Inserir no fim
                scoreFim->prox = novaNode;
                novaNode->ant = scoreFim;
                scoreFim = novaNode;
            } else if (atual == scoreInicio) { // Inserir no inicio
                novaNode->prox = scoreInicio;
                scoreInicio->ant = novaNode;
                scoreInicio = novaNode;
            } else { // Inserir no meio
                novaNode->prox = atual;
                novaNode->ant = atual->ant;
                atual->ant->prox = novaNode;
                atual->ant = novaNode;
            }
        }
    }

    void atualizarScore(const string& nomeJogador, bool venceu) {
        ScoreNodo* atual = scoreInicio;
        while (atual != nullptr) {
            if (atual->jogador.nome == nomeJogador) {
                atual->jogador.total_jogos++;
                if (venceu) {
                    atual->jogador.vitorias++;
                } else {
                    atual->jogador.derrotas++;
                }
                // Remover e adicionar novamente para manter a ordenacao
                jogadorScore tempJogador = atual->jogador; // Salva os dados antes de remover o nó
                removerScoreNode(atual);
                adicionarScore(tempJogador); // Adiciona novamente para reordenar
                return;
            }
            atual = atual->prox;
        }

        // Se o jogador nao foi encontrado, adiciona um novo
        jogadorScore novo = {nomeJogador, 1, (venceu ? 1 : 0), (venceu ? 0 : 1)};
        adicionarScore(novo);
    }

    void removerScoreNode(ScoreNodo* nodeToRemove) {
        if (nodeToRemove == nullptr) return;

        if (nodeToRemove->ant) {
            nodeToRemove->ant->prox = nodeToRemove->prox;
        } else { // Era o inicio
            scoreInicio = nodeToRemove->prox;
        }

        if (nodeToRemove->prox) {
            nodeToRemove->prox->ant = nodeToRemove->ant;
        } else { // Era o fim
            scoreFim = nodeToRemove->ant;
        }
        delete nodeToRemove;
    }

    void verificarScore() {
        cout << "\n--- Score dos Jogadores ---" << endl;
        if (scoreInicio == nullptr) {
            cout << "Nenhum score registrado ainda." << endl;
            cout << "Pressione Enter para voltar ao menu..." << endl;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            return;
        }

        ScoreNodo* atual = scoreInicio;
        int rank = 1;
        while (atual != nullptr) {
            cout << rank << ". Nome: " << atual->jogador.nome
                 << " | Jogos: " << atual->jogador.total_jogos
                 << " | Vitorias: " << atual->jogador.vitorias
                 << " | Derrotas: " << atual->jogador.derrotas << endl;
            atual = atual->prox;
            rank++;
        }
        cout << "Pressione Enter para voltar ao menu..." << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    // Métodos de Jogo e Menu
    void exibirMenuPrincipal() {
        int escolha;
        do {
            cout << "\n=== JOGO-ED1: Uma Aventura com Árvores de Decisão ===" << endl
                 << "1. Conhecer a História do Jogo" << endl
                 << "2. Regras do Jogo" << endl
                 << "3. Jogar" << endl
                 << "4. Verificar Score" << endl
                 << "5. Informações Técnicas" << endl
                 << "0. Sair" << endl
                 << "-----------------------------------------------------" << endl
                 << "Escolha uma opção: ";
            cin >> escolha;
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Limpa o buffer

            switch (escolha) {
                case 1:
                    mostrarHistoria();
                    break;
                case 2:
                    mostrarRegras();
                    break;
                case 3:
                    // Inicia o jogo a partir da raiz da árvore de cenas
                    cout << "\n--- Iniciar Novo Jogo ---" << endl;
                    cout << "Qual o seu nome, aventureiro? ";
                    getline(cin, jogadorAtualNome);
                    jogarCena(raizCena);
                    exibirMenuPosJogo(); // Exibe menu pós-jogo após o término da cena
                    break;
                case 4:
                    verificarScore();
                    break;
                case 5:
                    exibirInformacoesTecnicas();
                    break;
                case 0:
                    gerenciarSaida();
                    cout << "Obrigado por jogar! Saindo..." << endl;
                    exit(0);
                    break;
                default:
                    cout << "Opção inválida. Tente novamente." << endl;
            }
        } while (escolha != 0);
    }

    void mostrarHistoria() {
        cout << "\n--- História do Jogo ---" << endl;
        cout << "Este é um jogo de aventura onde suas escolhas moldam seu destino." << endl;
        cout << "Você acorda em um local misterioso e deve navegar por caminhos perigosos." << endl;
        cout << "Cada decisão pode levar a uma vitória gloriosa ou a uma derrota inesperada." << endl;
        cout << "Boa sorte, aventureiro!" << endl;
        cout << "Pressione Enter para voltar ao menu..." << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    void mostrarRegras() {
        cout << "\n--- Regras do Jogo ---" << endl;
        cout << "1. Leia atentamente a descrição de cada cena." << endl;
        cout << "2. Escolha entre as opções disponíveis (geralmente 1 ou 2)." << endl;
        cout << "3. Suas escolhas são permanentes e afetarão o desfecho do jogo." << endl;
        cout << "4. O objetivo é alcançar um final de vitória. Um final de derrota termina o jogo." << endl;
        cout << "Pressione Enter para voltar ao menu..." << endl;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    // Menu Pós-Jogo
    void exibirMenuPosJogo() {
        int escolha;
        do {
            cout << "\n--- Fim de Jogo ---" << endl;
            cout << "1. Deseja Jogar Novamente?" << endl;
            cout << "2. Verificar Score" << endl;
            cout << "0. Fechar o jogo" << endl;
            cout << "----------------------" << endl;
            cout << "Escolha uma opção: ";
            cin >> escolha;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            switch (escolha) {
                case 1:
                    cout << "Iniciando um novo jogo..." << endl;
                    // Ao jogar novamente, o Jogo::jogarCena será chamado do menu principal
                    // e irá pegar uma nova cena raiz (c1).
                    return; // Retorna para o loop do menu principal que chamará jogar() novamente
                case 2:
                    verificarScore();
                    break;
                case 0:
                    cout << "Fechando o jogo. Obrigado por jogar!" << endl;
                    gerenciarSaida();
                    exit(0);
                    break;
                default:
                    cout << "Opção inválida. Tente novamente." << endl;
            }
        } while (escolha != 0);
    }

    // Menu de Informações Técnicas
    void exibirInformacoesTecnicas() {
        int escolha;
        do {
            cout << "\n--- Informações Técnicas ---" << endl;
            cout << "1. Mostrar a descrição da Cena Raiz" << endl;
            cout << "2. Listar a árvore de cenas (percurso Pre-Ordem)" << endl;
            cout << "3. Buscar estatísticas de jogo por nome/vitórias" << endl;
            cout << "0. Voltar ao menu anterior" << endl;
            cout << "----------------------------" << endl;
            cout << "Escolha uma opção: ";
            cin >> escolha;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            switch (escolha) {
                case 1:
                    cout << "\n--- Descrição da Cena Raiz ---" << endl;
                    if (raizCena) cout << raizCena->texto << endl;
                    else cout << "Árvore de cenas não construída." << endl;
                    break;
                case 2:
                    cout << "\n--- Listando Árvore em Pre-Ordem ---" << endl;
                    if (raizCena) {
                        listarCenasEmOrdem(raizCena);
                    } else {
                        cout << "Árvore de cenas vazia." << endl;
                    }
                    break;
                case 3:
                    buscarEstatisticas();
                    break;
                case 0:
                    cout << "Voltando..." << endl;
                    break;
                default:
                    cout << "Opção inválida. Tente novamente." << endl;
            }
            cout << "Pressione Enter para continuar..." << endl;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        } while (escolha != 0);
    }

    // Função recursiva para percorrer e listar as cenas em Pre-Ordem (adaptado para Cena*)
    void listarCenasEmOrdem(Cena* cena) {
        if (cena == nullptr) return;

        cout << "Cena: ";
        if (!cena->texto.empty()) {
            if (cena->texto.length() > 50) { // Mostra um trecho se for muito longo
                cout << "\"" << cena->texto.substr(0, 50) << "..." << "\"" << endl;
            } else {
                cout << "\"" << cena->texto << "\"" << endl;
            }
        } else {
            cout << "(Sem texto)" << endl;
        }

        listarCenasEmOrdem(cena->op1); // Visita a subárvore da opção 1
        listarCenasEmOrdem(cena->op2); // Visita a subárvore da opção 2
    }

    void buscarEstatisticas() {
        cout << "\n--- Buscar Estatísticas ---" << endl;
        cout << "1. Buscar por nome do jogador" << endl;
        cout << "2. Buscar por número de vitórias (Mínimo)" << endl;
        cout << "0. Voltar" << endl;
        cout << "Escolha uma opção: ";

        int escolha;
        cin >> escolha;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        switch (escolha) {
            case 1: {
                string nomeBusca;
                cout << "Digite o nome do jogador: ";
                getline(cin, nomeBusca);
                ScoreNodo* atual = scoreInicio;
                bool encontrado = false;
                while (atual != nullptr) {
                    if (atual->jogador.nome == nomeBusca) {
                        cout << "Nome: " << atual->jogador.nome
                             << " | Jogos: " << atual->jogador.total_jogos
                             << " | Vitórias: " << atual->jogador.vitorias
                             << " | Derrotas: " << atual->jogador.derrotas << endl;
                        encontrado = true;
                        break;
                    }
                    atual = atual->prox;
                }
                if (!encontrado) {
                    cout << "Jogador '" << nomeBusca << "' não encontrado." << endl;
                }
                break;
            }
            case 2: {
                int minVitorias;
                cout << "Digite o número mínimo de vitórias: ";
                cin >> minVitorias;
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
                ScoreNodo* atual = scoreInicio;
                bool encontrado = false;
                cout << "Jogadores com " << minVitorias << " ou mais vitórias:" << endl;
                while (atual != nullptr) {
                    if (atual->jogador.vitorias >= minVitorias) {
                        cout << "Nome: " << atual->jogador.nome
                             << " | Jogos: " << atual->jogador.total_jogos
                             << " | Vitórias: " << atual->jogador.vitorias
                             << " | Derrotas: " << atual->jogador.derrotas << endl;
                        encontrado = true;
                    }
                    atual = atual->prox;
                }
                if (!encontrado) {
                    cout << "Nenhum jogador encontrado com essa quantidade de vitórias." << endl;
                }
                break;
            }
            case 0:
                break;
            default:
                cout << "Opção inválida." << endl;
        }
    }

    void gerenciarSaida() {
        int escolhaSalvar;
        cout << "Deseja salvar seu progresso antes de sair?" << endl;
        cout << "1. Sim" << endl;
        cout << "2. Não" << endl;
        cout << "Escolha: ";
        cin >> escolhaSalvar;
        cin.ignore(numeric_limits<streamsize>::max(), '\n'); // Limpa buffer
        if (escolhaSalvar == 1) {
            salvarScores();
            cout << "Scores salvos com sucesso!" << endl;
        } else {
            cout << "Scores não salvos." << endl;
        }
    }

    // Destrutor e Liberação de Memória
    ~Jogo() {
        salvarScores(); // Salva scores ao fechar o programa
        destruirCenas(raizCena); // Libera a memória da árvore de cenas
        destruirScores();        // Libera a memória da lista de scores
    }

private:
    // Funções auxiliares para destruir a árvore de cenas e liberar memória
    void destruirCenas(Cena* cena) {
        if (cena == nullptr) return;
        destruirCenas(cena->op1);
        destruirCenas(cena->op2);
        delete cena;
    }

    void destruirScores() {
        ScoreNodo* atual = scoreInicio;
        while (atual != nullptr) {
            ScoreNodo* temp = atual;
            atual = atual->prox;
            delete temp;
        }
        scoreInicio = nullptr;
        scoreFim = nullptr;
    }

    void salvarScores() {
        ofstream arquivo("scores.txt");
        if (!arquivo.is_open()) {
            cout << "Erro ao abrir o arquivo para salvar scores." << endl;
            return;
        }
        ScoreNodo* atual = scoreInicio;
        if (atual == nullptr) {
            cout << "Nenhum score para salvar." << endl;
            arquivo.close();
            return;
        } else {
            while (atual != nullptr) {
                arquivo << atual->jogador.nome << ","
                        << atual->jogador.total_jogos << ","
                        << atual->jogador.vitorias << ","
                        << atual->jogador.derrotas << endl;
                atual = atual->prox;
            }
        }
        arquivo.close();
        cout << "(Scores salvos no arquivo 'scores.txt')" << endl;
    }
};

// Função main para iniciar o jogo
int main() {
    Jogo meuJogo;
    meuJogo.exibirMenuPrincipal(); // Inicia o loop principal do menu
    return 0;
}
